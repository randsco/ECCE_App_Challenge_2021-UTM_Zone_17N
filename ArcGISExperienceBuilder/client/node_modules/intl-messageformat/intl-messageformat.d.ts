
declare type ArgumentElement = BaseElement<TYPE.argument>;

declare interface BaseElement<T extends TYPE> {
    type: T;
    value: string;
    location?: Location_2;
}

export declare function createDefaultFormatters(cache?: FormatterCache): Formatters;

declare type DateElement = SimpleFormatElement<TYPE.date, DateTimeSkeleton>;

declare interface DateTimeSkeleton {
    type: SKELETON_TYPE.dateTime;
    pattern: string;
    location?: Location_2;
}

export declare const enum ErrorCode {
    MISSING_VALUE = "MISSING_VALUE",
    INVALID_VALUE = "INVALID_VALUE",
    MISSING_INTL_API = "MISSING_INTL_API"
}

export declare class FormatError extends Error {
    readonly code: ErrorCode;
    /**
     * Original message we're trying to format
     * `undefined` if we're only dealing w/ AST
     *
     * @type {(string | undefined)}
     * @memberof FormatError
     */
    readonly originalMessage: string | undefined;
    constructor(msg: string, code: ErrorCode, originalMessage?: string);
    toString(): string;
}

export declare interface Formats {
    number: Record<string, Intl.NumberFormatOptions>;
    date: Record<string, Intl.DateTimeFormatOptions>;
    time: Record<string, Intl.DateTimeFormatOptions>;
}

export declare interface FormatterCache {
    number: Record<string, Intl.NumberFormat>;
    dateTime: Record<string, Intl.DateTimeFormat>;
    pluralRules: Record<string, Intl.PluralRules>;
}

export declare interface Formatters {
    getNumberFormat(...args: ConstructorParameters<typeof Intl.NumberFormat>): Intl.NumberFormat;
    getDateTimeFormat(...args: ConstructorParameters<typeof Intl.DateTimeFormat>): Intl.DateTimeFormat;
    getPluralRules(...args: ConstructorParameters<typeof Intl.PluralRules>): Intl.PluralRules;
}

export declare function formatToParts<T>(els: MessageFormatElement[], locales: string | string[], formatters: Formatters, formats: Formats, values?: Record<string, PrimitiveType | T | FormatXMLElementFn<T>>, currentPluralValue?: number, originalMessage?: string): MessageFormatPart<T>[];

export declare type FormatXMLElementFn<T, R = string | Array<string | T>> = (parts: Array<string | T>) => R;

declare class IntlMessageFormat {
    private readonly ast;
    private readonly locales;
    private readonly formatters;
    private readonly formats;
    private readonly message;
    private readonly formatterCache;
    constructor(message: string | MessageFormatElement[], locales?: string | string[], overrideFormats?: Partial<Formats>, opts?: Options);
    format: <T = void>(values?: Record<string, string | number | boolean | Date | T | FormatXMLElementFn<T, string | (string | T)[]> | null | undefined> | undefined) => string | T | (string | T)[];
    formatToParts: <T>(values?: Record<string, string | number | boolean | Date | T | FormatXMLElementFn<T, string | (string | T)[]> | null | undefined> | undefined) => MessageFormatPart<T>[];
    resolvedOptions: () => {
        locale: string;
    };
    getAst: () => MessageFormatElement[];
    private static memoizedDefaultLocale;
    static get defaultLocale(): string;
    static __parse: typeof parse | undefined;
    static formats: {
        number: {
            currency: {
                style: string;
            };
            percent: {
                style: string;
            };
        };
        date: {
            short: {
                month: string;
                day: string;
                year: string;
            };
            medium: {
                month: string;
                day: string;
                year: string;
            };
            long: {
                month: string;
                day: string;
                year: string;
            };
            full: {
                weekday: string;
                month: string;
                day: string;
                year: string;
            };
        };
        time: {
            short: {
                hour: string;
                minute: string;
            };
            medium: {
                hour: string;
                minute: string;
                second: string;
            };
            long: {
                hour: string;
                minute: string;
                second: string;
                timeZoneName: string;
            };
            full: {
                hour: string;
                minute: string;
                second: string;
                timeZoneName: string;
            };
        };
    };
}
export { IntlMessageFormat }
export default IntlMessageFormat;

export declare class InvalidValueError extends FormatError {
    constructor(variableId: string, value: any, options: string[], originalMessage?: string);
}

export declare class InvalidValueTypeError extends FormatError {
    constructor(value: any, type: string, originalMessage?: string);
}

declare interface IParseOptions {
    filename?: string;
    startRule?: string;
    tracer?: any;
    [key: string]: any;
}

export declare function isFormatXMLElementFn<T>(el: PrimitiveType | T | FormatXMLElementFn<T>): el is FormatXMLElementFn<T>;

declare type LiteralElement = BaseElement<TYPE.literal>;

export declare interface LiteralPart {
    type: PART_TYPE.literal;
    value: string;
}

declare interface Location_2 {
    start: LocationDetails;
    end: LocationDetails;
}

declare interface LocationDetails {
    offset: number;
    line: number;
    column: number;
}

declare type MessageFormatElement = LiteralElement | ArgumentElement | NumberElement | DateElement | TimeElement | SelectElement | PluralElement | TagElement | PoundElement;

export declare type MessageFormatPart<T> = LiteralPart | ObjectPart<T>;

export declare class MissingValueError extends FormatError {
    constructor(variableId: string, originalMessage?: string);
}

declare type NumberElement = SimpleFormatElement<TYPE.number, NumberSkeleton>;

declare interface NumberSkeleton {
    type: SKELETON_TYPE.number;
    tokens: NumberSkeletonToken[];
    location?: Location_2;
}

declare interface NumberSkeletonToken {
    stem: string;
    options: string[];
}

export declare interface ObjectPart<T = any> {
    type: PART_TYPE.object;
    value: T;
}

export declare interface Options {
    formatters?: Formatters;
    /**
     * Whether to treat HTML/XML tags as string literal
     * instead of parsing them as tag token.
     * When this is false we only allow simple tags without
     * any attributes
     */
    ignoreTag?: boolean;
}

declare interface Options_2 {
    /**
     * Whether to convert `#` in plural rule options
     * to `{var, number}`
     * Default is true
     */
    normalizeHashtagInPlural?: boolean;
    /**
     * Capture location info in AST
     * Default is false
     */
    captureLocation?: boolean;
    /**
     * Whether to treat HTML/XML tags as string literal
     * instead of parsing them as tag token.
     * When this is false we only allow simple tags without
     * any attributes
     */
    ignoreTag?: boolean;
}

declare function parse(input: string, opts?: ParseOptions): MessageFormatElement[];

declare type ParseOptions = Options_2 & IParseOptions;

export declare const enum PART_TYPE {
    literal = 0,
    object = 1
}

declare interface PluralElement extends BaseElement<TYPE.plural> {
    options: Record<ValidPluralRule, PluralOrSelectOption>;
    offset: number;
    pluralType: Intl.PluralRulesOptions['type'];
}

declare interface PluralOrSelectOption {
    value: MessageFormatElement[];
    location?: Location_2;
}

declare interface PoundElement {
    type: TYPE.pound;
    location?: Location_2;
}

export declare type PrimitiveType = string | number | boolean | null | undefined | Date;

declare interface SelectElement extends BaseElement<TYPE.select> {
    options: Record<string, PluralOrSelectOption>;
}

declare interface SimpleFormatElement<T extends TYPE, S extends Skeleton> extends BaseElement<T> {
    style?: string | S | null;
}

declare type Skeleton = NumberSkeleton | DateTimeSkeleton;

declare const enum SKELETON_TYPE {
    number = 0,
    dateTime = 1
}

declare interface TagElement {
    type: TYPE.tag;
    value: string;
    children: MessageFormatElement[];
    location?: Location_2;
}

declare type TimeElement = SimpleFormatElement<TYPE.time, DateTimeSkeleton>;

declare enum TYPE {
    /**
     * Raw text
     */
    literal = 0,
    /**
     * Variable w/o any format, e.g `var` in `this is a {var}`
     */
    argument = 1,
    /**
     * Variable w/ number format
     */
    number = 2,
    /**
     * Variable w/ date format
     */
    date = 3,
    /**
     * Variable w/ time format
     */
    time = 4,
    /**
     * Variable w/ select format
     */
    select = 5,
    /**
     * Variable w/ plural format
     */
    plural = 6,
    /**
     * Only possible within plural argument.
     * This is the `#` symbol that will be substituted with the count.
     */
    pound = 7,
    /**
     * XML-like tag
     */
    tag = 8
}

declare type ValidPluralRule = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other' | string;

export { }
