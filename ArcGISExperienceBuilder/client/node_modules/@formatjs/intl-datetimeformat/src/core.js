"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var intl_utils_1 = require("@formatjs/intl-utils");
var get_internal_slots_1 = require("./get_internal_slots");
var links_1 = require("./data/links");
var packer_1 = require("./packer");
var skeleton_1 = require("./skeleton");
var UPPERCASED_LINKS = Object.keys(links_1.default).reduce(function (all, l) {
    all[l.toUpperCase()] = links_1.default[l];
    return all;
}, {});
var DATE_TIME_PROPS = [
    'weekday',
    'era',
    'year',
    'month',
    'day',
    'hour',
    'minute',
    'second',
    'timeZoneName',
];
var RESOLVED_OPTIONS_KEYS = [
    'locale',
    'calendar',
    'numberingSystem',
    'dateStyle',
    'timeStyle',
    'timeZone',
    'hourCycle',
    'weekday',
    'era',
    'year',
    'month',
    'day',
    'hour',
    'minute',
    'second',
    'timeZoneName',
];
var TYPE_REGEX = /^[a-z0-9]{3,8}$/i;
/**
 * https://tc39.es/ecma402/#sec-isvalidtimezonename
 * @param tz
 */
function isValidTimeZoneName(tz) {
    var uppercasedTz = tz.toUpperCase();
    var zoneNames = new Set(Object.keys(exports.DateTimeFormat.tzData).map(function (z) { return z.toUpperCase(); }));
    return zoneNames.has(uppercasedTz) || uppercasedTz in UPPERCASED_LINKS;
}
/**
 * https://tc39.es/ecma402/#sec-canonicalizetimezonename
 * @param tz
 */
function canonicalizeTimeZoneName(tz) {
    var uppercasedTz = tz.toUpperCase();
    var uppercasedZones = Object.keys(exports.DateTimeFormat.tzData).reduce(function (all, z) {
        all[z.toUpperCase()] = z;
        return all;
    }, {});
    var ianaTimeZone = UPPERCASED_LINKS[uppercasedTz] || uppercasedZones[uppercasedTz];
    if (ianaTimeZone === 'Etc/UTC' || ianaTimeZone === 'Etc/GMT') {
        return 'UTC';
    }
    return ianaTimeZone;
}
/**
 * https://tc39.es/ecma262/#sec-tonumber
 * @param val
 */
function toNumber(val) {
    if (val === undefined) {
        return NaN;
    }
    if (val === null) {
        return +0;
    }
    if (typeof val === 'boolean') {
        return val ? 1 : +0;
    }
    if (typeof val === 'number') {
        return val;
    }
    if (typeof val === 'symbol' || typeof val === 'bigint') {
        throw new TypeError('Cannot convert symbol/bigint to number');
    }
    return Number(val);
}
/**
 * https://tc39.es/ecma262/#sec-tointeger
 * @param n
 */
function toInteger(n) {
    var number = toNumber(n);
    if (isNaN(number) || intl_utils_1.objectIs(number, -0)) {
        return 0;
    }
    if (isFinite(number)) {
        return number;
    }
    var integer = Math.floor(Math.abs(number));
    if (number < 0) {
        integer = -integer;
    }
    if (intl_utils_1.objectIs(integer, -0)) {
        return 0;
    }
    return integer;
}
/**
 * https://tc39.es/ecma262/#sec-timeclip
 * @param time
 */
function timeClip(time) {
    if (!isFinite(time)) {
        return NaN;
    }
    if (Math.abs(time) > 8.64 * 1e16) {
        return NaN;
    }
    return toInteger(time);
}
/**
 * https://tc39.es/ecma402/#sec-initializedatetimeformat
 * @param dtf DateTimeFormat
 * @param locales locales
 * @param opts options
 */
function initializeDateTimeFormat(dtf, locales, opts) {
    // @ts-ignore
    var requestedLocales = Intl.getCanonicalLocales(locales);
    var options = toDateTimeOptions(opts, 'any', 'date');
    var opt = Object.create(null);
    var matcher = intl_utils_1.getOption(options, 'localeMatcher', 'string', ['lookup', 'best fit'], 'best fit');
    opt.localeMatcher = matcher;
    var calendar = intl_utils_1.getOption(options, 'calendar', 'string', undefined, undefined);
    if (calendar !== undefined && !TYPE_REGEX.test(calendar)) {
        throw new RangeError('Malformed calendar');
    }
    var internalSlots = get_internal_slots_1.default(dtf);
    opt.ca = calendar;
    var numberingSystem = intl_utils_1.getOption(options, 'numberingSystem', 'string', undefined, undefined);
    if (numberingSystem !== undefined && !TYPE_REGEX.test(numberingSystem)) {
        throw new RangeError('Malformed numbering system');
    }
    opt.nu = numberingSystem;
    var hour12 = intl_utils_1.getOption(options, 'hour12', 'boolean', undefined, undefined);
    var hourCycle = intl_utils_1.getOption(options, 'hourCycle', 'string', ['h11', 'h12', 'h23', 'h24'], undefined);
    if (hour12 !== undefined) {
        // @ts-ignore
        hourCycle = null;
    }
    opt.hc = hourCycle;
    var r = intl_utils_1.createResolveLocale(exports.DateTimeFormat.getDefaultLocale)(exports.DateTimeFormat.availableLocales, requestedLocales, 
    // TODO: Fix the type
    opt, 
    // [[RelevantExtensionKeys]] slot, which is a constant
    ['nu', 'ca', 'hc'], exports.DateTimeFormat.localeData);
    internalSlots.locale = r.locale;
    calendar = r.ca;
    internalSlots.calendar = calendar;
    internalSlots.hourCycle = r.hc;
    internalSlots.numberingSystem = r.nu;
    var dataLocale = r.dataLocale;
    internalSlots.dataLocale = dataLocale;
    var timeZone = options.timeZone;
    if (timeZone !== undefined) {
        timeZone = String(timeZone);
        if (!isValidTimeZoneName(timeZone)) {
            throw new RangeError('Invalid timeZoneName');
        }
        timeZone = canonicalizeTimeZoneName(timeZone);
    }
    else {
        timeZone = exports.DateTimeFormat.__defaultLocale;
    }
    internalSlots.timeZone = timeZone;
    opt = Object.create(null);
    opt.weekday = intl_utils_1.getOption(options, 'weekday', 'string', ['narrow', 'short', 'long'], undefined);
    opt.era = intl_utils_1.getOption(options, 'era', 'string', ['narrow', 'short', 'long'], undefined);
    opt.year = intl_utils_1.getOption(options, 'year', 'string', ['2-digit', 'numeric'], undefined);
    opt.month = intl_utils_1.getOption(options, 'month', 'string', ['2-digit', 'numeric', 'narrow', 'short', 'long'], undefined);
    opt.day = intl_utils_1.getOption(options, 'day', 'string', ['2-digit', 'numeric'], undefined);
    opt.hour = intl_utils_1.getOption(options, 'hour', 'string', ['2-digit', 'numeric'], undefined);
    opt.minute = intl_utils_1.getOption(options, 'minute', 'string', ['2-digit', 'numeric'], undefined);
    opt.second = intl_utils_1.getOption(options, 'second', 'string', ['2-digit', 'numeric'], undefined);
    opt.timeZoneName = intl_utils_1.getOption(options, 'timeZoneName', 'string', ['short', 'long'], undefined);
    var dataLocaleData = exports.DateTimeFormat.localeData[dataLocale];
    var formats = dataLocaleData.formats[calendar];
    matcher = intl_utils_1.getOption(options, 'formatMatcher', 'string', ['basic', 'best fit'], 'best fit');
    var dateStyle = intl_utils_1.getOption(options, 'dateStyle', 'string', ['full', 'long', 'medium', 'short'], undefined);
    internalSlots.dateStyle = dateStyle;
    var timeStyle = intl_utils_1.getOption(options, 'timeStyle', 'string', ['full', 'long', 'medium', 'short'], undefined);
    internalSlots.timeStyle = timeStyle;
    var bestFormat;
    if (dateStyle === undefined && timeStyle === undefined) {
        if (matcher === 'basic') {
            bestFormat = basicFormatMatcher(opt, formats);
        }
        else {
            opt.hour12 =
                internalSlots.hourCycle === 'h11' || internalSlots.hourCycle === 'h12';
            bestFormat = bestFitFormatMatcher(opt, formats);
        }
    }
    else {
        for (var _i = 0, DATE_TIME_PROPS_1 = DATE_TIME_PROPS; _i < DATE_TIME_PROPS_1.length; _i++) {
            var prop = DATE_TIME_PROPS_1[_i];
            var p = opt[prop];
            if (p !== undefined) {
                throw new TypeError("Intl.DateTimeFormat can't set option " + prop + " when " + (dateStyle ? 'dateStyle' : 'timeStyle') + " is used");
            }
        }
        bestFormat = dateTimeStyleFormat(dateStyle, timeStyle, dataLocaleData);
    }
    for (var prop in opt) {
        var p = bestFormat[prop];
        if (p !== undefined) {
            internalSlots[prop] = p;
        }
    }
    var pattern;
    if (internalSlots.hour !== undefined) {
        var hcDefault = dataLocaleData.hourCycle;
        var hc = internalSlots.hourCycle;
        if (hc == null) {
            hc = hcDefault;
        }
        if (hour12 !== undefined) {
            if (hour12) {
                if (hcDefault === 'h11' || hcDefault === 'h23') {
                    hc = 'h11';
                }
                else {
                    hc = 'h12';
                }
            }
            else {
                intl_utils_1.invariant(!hour12, 'hour12 must not be set');
                if (hcDefault === 'h11' || hcDefault === 'h23') {
                    hc = 'h23';
                }
                else {
                    hc = 'h24';
                }
            }
        }
        internalSlots.hourCycle = hc;
        if (hc === 'h11' || hc === 'h12') {
            pattern = bestFormat.pattern12;
        }
        else {
            pattern = bestFormat.pattern;
        }
    }
    else {
        // @ts-ignore
        internalSlots.hourCycle = undefined;
        pattern = bestFormat.pattern;
    }
    internalSlots.pattern = pattern;
    return dtf;
}
/**
 * https://tc39.es/ecma402/#sec-todatetimeoptions
 * @param options
 * @param required
 * @param defaults
 */
function toDateTimeOptions(options, required, defaults) {
    if (options === undefined) {
        options = null;
    }
    else {
        options = intl_utils_1.toObject(options);
    }
    options = Object.create(options);
    var needDefaults = true;
    if (required === 'date' || required === 'any') {
        for (var _i = 0, _a = ['weekday', 'year', 'month', 'day']; _i < _a.length; _i++) {
            var prop = _a[_i];
            var value = options[prop];
            if (value !== undefined) {
                needDefaults = false;
            }
        }
    }
    if (required === 'time' || required === 'any') {
        for (var _b = 0, _c = ['hour', 'minute', 'second']; _b < _c.length; _b++) {
            var prop = _c[_b];
            var value = options[prop];
            if (value !== undefined) {
                needDefaults = false;
            }
        }
    }
    if (options.dateStyle !== undefined || options.timeStyle !== undefined) {
        needDefaults = false;
    }
    if (required === 'date' && options.timeStyle) {
        throw new TypeError('Intl.DateTimeFormat date was required but timeStyle was included');
    }
    if (required === 'time' && options.dateStyle) {
        throw new TypeError('Intl.DateTimeFormat time was required but dateStyle was included');
    }
    if (needDefaults && (defaults === 'date' || defaults === 'all')) {
        for (var _d = 0, _e = ['year', 'month', 'day']; _d < _e.length; _d++) {
            var prop = _e[_d];
            options[prop] = 'numeric';
        }
    }
    if (needDefaults && (defaults === 'time' || defaults === 'all')) {
        for (var _f = 0, _g = ['hour', 'minute', 'second']; _f < _g.length; _f++) {
            var prop = _g[_f];
            options[prop] = 'numeric';
        }
    }
    return options;
}
exports.toDateTimeOptions = toDateTimeOptions;
var BASIC_FORMAT_MATCHER_VALUES = [
    '2-digit',
    'numeric',
    'narrow',
    'short',
    'long',
];
var removalPenalty = 120;
var additionPenalty = 20;
var longLessPenalty = 8;
var longMorePenalty = 6;
var shortLessPenalty = 6;
var shortMorePenalty = 3;
function basicFormatMatcherScore(options, format) {
    var score = 0;
    for (var _i = 0, DATE_TIME_PROPS_2 = DATE_TIME_PROPS; _i < DATE_TIME_PROPS_2.length; _i++) {
        var prop = DATE_TIME_PROPS_2[_i];
        var optionsProp = options[prop];
        var formatProp = format[prop];
        if (optionsProp === undefined && formatProp !== undefined) {
            score -= additionPenalty;
        }
        else if (optionsProp !== undefined && formatProp === undefined) {
            score -= removalPenalty;
        }
        else if (optionsProp !== formatProp) {
            var optionsPropIndex = BASIC_FORMAT_MATCHER_VALUES.indexOf(optionsProp);
            var formatPropIndex = BASIC_FORMAT_MATCHER_VALUES.indexOf(formatProp);
            var delta = Math.max(-2, Math.min(formatPropIndex - optionsPropIndex, 2));
            if (delta === 2) {
                score -= longMorePenalty;
            }
            else if (delta === 1) {
                score -= shortMorePenalty;
            }
            else if (delta === -1) {
                score -= shortLessPenalty;
            }
            else if (delta === -2) {
                score -= longLessPenalty;
            }
        }
    }
    return score;
}
exports.basicFormatMatcherScore = basicFormatMatcherScore;
/**
 * Credit: https://github.com/andyearnshaw/Intl.js/blob/0958dc1ad8153f1056653ea22b8208f0df289a4e/src/12.datetimeformat.js#L611
 * with some modifications
 * @param options
 * @param format
 */
function bestFitFormatMatcherScore(options, format) {
    var score = 0;
    if (options.hour12 && !format.hour12) {
        score -= removalPenalty;
    }
    else if (!options.hour12 && format.hour12) {
        score -= additionPenalty;
    }
    for (var _i = 0, DATE_TIME_PROPS_3 = DATE_TIME_PROPS; _i < DATE_TIME_PROPS_3.length; _i++) {
        var prop = DATE_TIME_PROPS_3[_i];
        var optionsProp = options[prop];
        var formatProp = format[prop];
        if (optionsProp === undefined && formatProp !== undefined) {
            score -= additionPenalty;
        }
        else if (optionsProp !== undefined && formatProp === undefined) {
            score -= removalPenalty;
        }
        else if (optionsProp !== formatProp) {
            var optionsPropIndex = BASIC_FORMAT_MATCHER_VALUES.indexOf(optionsProp);
            var formatPropIndex = BASIC_FORMAT_MATCHER_VALUES.indexOf(formatProp);
            var delta = Math.max(-2, Math.min(formatPropIndex - optionsPropIndex, 2));
            if (delta === 2) {
                score -= longMorePenalty;
            }
            else if (delta === 1) {
                score -= shortMorePenalty;
            }
            else if (delta === -1) {
                score -= shortLessPenalty;
            }
            else if (delta === -2) {
                score -= longLessPenalty;
            }
        }
    }
    return score;
}
exports.bestFitFormatMatcherScore = bestFitFormatMatcherScore;
function dateTimeStyleFormat(dateStyle, timeStyle, dataLocaleData) {
    var dateFormat, timeFormat;
    if (timeStyle !== undefined) {
        timeFormat = dataLocaleData.timeFormat[timeStyle];
    }
    if (dateStyle !== undefined) {
        dateFormat = dataLocaleData.dateFormat[dateStyle];
    }
    if (dateStyle !== undefined &&
        dateFormat !== undefined &&
        timeFormat !== undefined) {
        var format = __assign(__assign({}, dateFormat), timeFormat);
        delete format.pattern;
        delete format.pattern12;
        var connector = dataLocaleData.dateTimeFormat[dateStyle];
        format.pattern = connector
            .replace('{0}', timeFormat.pattern)
            .replace('{1}', dateFormat.pattern);
        if (timeFormat.pattern12 !== undefined) {
            format.pattern12 = connector
                .replace('{0}', timeFormat.pattern12)
                .replace('{1}', dateFormat.pattern);
        }
        return format;
    }
    if (timeFormat !== undefined) {
        return timeFormat;
    }
    if (dateFormat === undefined) {
        throw new TypeError('Intl.DateTimeFormat neither the dateFormat or the timeFormat could be found');
    }
    return dateFormat;
}
/**
 * https://tc39.es/ecma402/#sec-basicformatmatcher
 * @param options
 * @param formats
 */
function basicFormatMatcher(options, formats) {
    var bestScore = -Infinity;
    var bestFormat = formats[0];
    intl_utils_1.invariant(Array.isArray(formats), 'formats should be a list of things');
    for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {
        var format = formats_1[_i];
        var score = basicFormatMatcherScore(options, format);
        if (score > bestScore) {
            bestScore = score;
            bestFormat = format;
        }
    }
    return __assign({}, bestFormat);
}
function isNumericType(t) {
    return t === 'numeric' || t === '2-digit';
}
/**
 * https://tc39.es/ecma402/#sec-bestfitformatmatcher
 * Just alias to basic for now
 * @param options
 * @param formats
 */
function bestFitFormatMatcher(options, formats) {
    var bestScore = -Infinity;
    var bestFormat = formats[0];
    intl_utils_1.invariant(Array.isArray(formats), 'formats should be a list of things');
    for (var _i = 0, formats_2 = formats; _i < formats_2.length; _i++) {
        var format = formats_2[_i];
        var score = bestFitFormatMatcherScore(options, format);
        if (score > bestScore) {
            bestScore = score;
            bestFormat = format;
        }
    }
    bestFormat = __assign({}, bestFormat);
    // Kinda following https://github.com/unicode-org/icu/blob/dd50e38f459d84e9bf1b0c618be8483d318458ad/icu4j/main/classes/core/src/com/ibm/icu/text/DateTimePatternGenerator.java
    for (var prop in bestFormat) {
        var bestValue = bestFormat[prop];
        var inputValue = options[prop];
        // Don't mess with minute/second or we can get in the situation of
        // 7:0:0 which is weird
        if (prop === 'minute' || prop === 'second') {
            continue;
        }
        // Nothing to do here
        if (!inputValue) {
            continue;
        }
        // https://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons
        // Looks like we should not convert numeric to alphabetic but the other way
        // around is ok
        if (isNumericType(bestValue) &&
            !isNumericType(inputValue)) {
            continue;
        }
        // Otherwise use the input value
        bestFormat[prop] = inputValue;
    }
    return bestFormat;
}
var formatDescriptor = {
    enumerable: false,
    configurable: true,
    get: function () {
        if (typeof this !== 'object' || !(this instanceof exports.DateTimeFormat)) {
            throw TypeError('Intl.DateTimeFormat format property accessor called on incompatible receiver');
        }
        var internalSlots = get_internal_slots_1.default(this);
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var dtf = this;
        var boundFormat = internalSlots.boundFormat;
        if (boundFormat === undefined) {
            // https://tc39.es/proposal-unified-intl-numberformat/section11/numberformat_diff_out.html#sec-number-format-functions
            boundFormat = function (date) {
                var x;
                if (date === undefined) {
                    x = Date.now();
                }
                else {
                    x = Number(date);
                }
                return formatDateTime(dtf, x);
            };
            try {
                // https://github.com/tc39/test262/blob/master/test/intl402/NumberFormat/prototype/format/format-function-name.js
                Object.defineProperty(boundFormat, 'name', {
                    configurable: true,
                    enumerable: false,
                    writable: false,
                    value: '',
                });
            }
            catch (e) {
                // In older browser (e.g Chrome 36 like polyfill.io)
                // TypeError: Cannot redefine property: name
            }
            internalSlots.boundFormat = boundFormat;
        }
        return boundFormat;
    },
};
try {
    // https://github.com/tc39/test262/blob/master/test/intl402/NumberFormat/prototype/format/name.js
    Object.defineProperty(formatDescriptor.get, 'name', {
        configurable: true,
        enumerable: false,
        writable: false,
        value: 'get format',
    });
}
catch (e) {
    // In older browser (e.g Chrome 36 like polyfill.io)
    // TypeError: Cannot redefine property: name
}
function pad(n) {
    if (n < 10) {
        return "0" + n;
    }
    return String(n);
}
function offsetToGmtString(gmtFormat, hourFormat, offsetInMs, style) {
    var offsetInMinutes = Math.floor(offsetInMs / 60000);
    var mins = Math.abs(offsetInMinutes) % 60;
    var hours = Math.floor(Math.abs(offsetInMinutes) / 60);
    var _a = hourFormat.split(';'), positivePattern = _a[0], negativePattern = _a[1];
    var offsetStr = '';
    var pattern = offsetInMs < 0 ? negativePattern : positivePattern;
    if (style === 'long') {
        offsetStr = pattern
            .replace('HH', pad(hours))
            .replace('H', String(hours))
            .replace('mm', pad(mins))
            .replace('m', String(mins));
    }
    else if (mins || hours) {
        if (!mins) {
            pattern = pattern.replace(/:?m+/, '');
        }
        offsetStr = pattern
            .replace(/H+/, String(hours))
            .replace(/m+/, String(mins));
    }
    return gmtFormat.replace('{0}', offsetStr);
}
/**
 * https://tc39.es/ecma402/#sec-partitiondatetimepattern
 * @param dtf
 * @param x
 */
function partitionDateTimePattern(dtf, x) {
    x = timeClip(x);
    if (isNaN(x)) {
        throw new RangeError('invalid time');
    }
    /** IMPL START */
    var internalSlots = get_internal_slots_1.default(dtf);
    var dataLocale = internalSlots.dataLocale;
    var dataLocaleData = exports.DateTimeFormat.localeData[dataLocale];
    /** IMPL END */
    var locale = internalSlots.locale;
    var nfOptions = Object.create(null);
    nfOptions.useGrouping = false;
    var nf = new Intl.NumberFormat(locale, nfOptions);
    var nf2Options = Object.create(null);
    nf2Options.minimumIntegerDigits = 2;
    nf2Options.useGrouping = false;
    var nf2 = new Intl.NumberFormat(locale, nf2Options);
    var tm = toLocalTime(x, 
    // @ts-ignore
    internalSlots.calendar, internalSlots.timeZone);
    var result = [];
    var patternParts = intl_utils_1.partitionPattern(internalSlots.pattern);
    for (var _i = 0, patternParts_1 = patternParts; _i < patternParts_1.length; _i++) {
        var patternPart = patternParts_1[_i];
        var p = patternPart.type;
        if (p === 'literal') {
            result.push({
                type: 'literal',
                value: patternPart.value,
            });
        }
        else if (DATE_TIME_PROPS.indexOf(p) > -1) {
            var fv = '';
            var f = internalSlots[p];
            // @ts-ignore
            var v = tm[p];
            if (p === 'year' && v <= 0) {
                v = 1 - v;
            }
            if (p === 'month') {
                v++;
            }
            var hourCycle = internalSlots.hourCycle;
            if (p === 'hour' && (hourCycle === 'h11' || hourCycle === 'h12')) {
                v = v % 12;
                if (v === 0 && hourCycle === 'h12') {
                    v = 12;
                }
            }
            if (p === 'hour' && hourCycle === 'h24') {
                if (v === 0) {
                    v = 24;
                }
            }
            if (f === 'numeric') {
                fv = nf.format(v);
            }
            else if (f === '2-digit') {
                fv = nf2.format(v);
                if (fv.length > 2) {
                    fv = fv.slice(fv.length - 2, fv.length);
                }
            }
            else if (f === 'narrow' || f === 'short' || f === 'long') {
                if (p === 'era') {
                    fv = dataLocaleData[p][f][v];
                }
                else if (p === 'timeZoneName') {
                    var timeZoneName = dataLocaleData.timeZoneName, gmtFormat = dataLocaleData.gmtFormat, hourFormat = dataLocaleData.hourFormat;
                    var timeZone = internalSlots.timeZone || exports.DateTimeFormat.__defaultTimeZone;
                    var timeZoneData = timeZoneName[timeZone];
                    if (timeZoneData && timeZoneData[f]) {
                        fv = timeZoneData[f][+tm.inDST];
                    }
                    else {
                        // Fallback to gmtFormat
                        fv = offsetToGmtString(gmtFormat, hourFormat, tm.timeZoneOffset, f);
                    }
                }
                else if (p === 'month') {
                    fv = dataLocaleData.month[f][v - 1];
                }
                else {
                    fv = dataLocaleData[p][f][v];
                }
            }
            result.push({
                type: p,
                value: fv,
            });
        }
        else if (p === 'ampm') {
            var v = tm.hour;
            var fv = void 0;
            if (v >= 11) {
                fv = dataLocaleData.pm;
            }
            else {
                fv = dataLocaleData.am;
            }
            result.push({
                type: 'dayPeriod',
                value: fv,
            });
        }
        else if (p === 'relatedYear') {
            var v = tm.relatedYear;
            // @ts-ignore
            var fv = nf.format(v);
            result.push({
                type: 'relatedYear',
                value: fv,
            });
        }
        else if (p === 'yearName') {
            var v = tm.yearName;
            // @ts-ignore
            var fv = nf.format(v);
            result.push({
                type: 'yearName',
                value: fv,
            });
        }
        else {
            result.push({
                type: 'unknown',
                value: x,
            });
        }
    }
    return result;
}
/**
 * https://tc39.es/ecma402/#sec-formatdatetime
 * @param dtf DateTimeFormat
 * @param x
 */
function formatDateTime(dtf, x) {
    var parts = partitionDateTimePattern(dtf, x);
    var result = '';
    for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
        var part = parts_1[_i];
        result += part.value;
    }
    return result;
}
/**
 * https://tc39.es/ecma402/#sec-formatdatetimetoparts
 * @param dtf DateTimeFormat
 * @param x
 */
function formatDateTimeParts(dtf, x) {
    return partitionDateTimePattern(dtf, x);
}
var MS_PER_DAY = 86400000;
/**
 * https://www.ecma-international.org/ecma-262/11.0/index.html#eqn-modulo
 * @param x
 * @param y
 * @return k of the same sign as y
 */
function mod(x, y) {
    return x - Math.floor(x / y) * y;
}
/**
 * https://tc39.es/ecma262/#eqn-Day
 * @param t
 */
function day(t) {
    return Math.floor(t / MS_PER_DAY);
}
/**
 * https://tc39.es/ecma262/#sec-week-day
 * @param t
 */
function weekDay(t) {
    return mod(day(t) + 4, 7);
}
function dayFromYear(y) {
    return (365 * (y - 1970) +
        Math.floor((y - 1969) / 4) -
        Math.floor((y - 1901) / 100) +
        Math.floor((y - 1601) / 400));
}
function timeFromYear(y) {
    return MS_PER_DAY * dayFromYear(y);
}
function yearFromTime(t) {
    var min = Math.ceil(t / MS_PER_DAY / 366);
    var y = min;
    while (timeFromYear(y) <= t) {
        y++;
    }
    return y - 1;
}
function daysInYear(y) {
    if (y % 4 !== 0) {
        return 365;
    }
    if (y % 100 !== 0) {
        return 366;
    }
    if (y % 400 !== 0) {
        return 365;
    }
    return 366;
}
function dayWithinYear(t) {
    return day(t) - dayFromYear(yearFromTime(t));
}
function inLeapYear(t) {
    return daysInYear(yearFromTime(t)) === 365 ? 0 : 1;
}
function monthFromTime(t) {
    var dwy = dayWithinYear(t);
    var leap = inLeapYear(t);
    if (dwy >= 0 && dwy < 31) {
        return 0;
    }
    if (dwy < 59 + leap) {
        return 1;
    }
    if (dwy < 90 + leap) {
        return 2;
    }
    if (dwy < 120 + leap) {
        return 3;
    }
    if (dwy < 151 + leap) {
        return 4;
    }
    if (dwy < 181 + leap) {
        return 5;
    }
    if (dwy < 212 + leap) {
        return 6;
    }
    if (dwy < 243 + leap) {
        return 7;
    }
    if (dwy < 273 + leap) {
        return 8;
    }
    if (dwy < 304 + leap) {
        return 9;
    }
    if (dwy < 334 + leap) {
        return 10;
    }
    if (dwy < 365 + leap) {
        return 11;
    }
    throw new Error('Invalid time');
}
function dateFromTime(t) {
    var dwy = dayWithinYear(t);
    var mft = monthFromTime(t);
    var leap = inLeapYear(t);
    if (mft === 0) {
        return dwy + 1;
    }
    if (mft === 1) {
        return dwy - 30;
    }
    if (mft === 2) {
        return dwy - 58 - leap;
    }
    if (mft === 3) {
        return dwy - 89 - leap;
    }
    if (mft === 4) {
        return dwy - 119 - leap;
    }
    if (mft === 5) {
        return dwy - 150 - leap;
    }
    if (mft === 6) {
        return dwy - 180 - leap;
    }
    if (mft === 7) {
        return dwy - 211 - leap;
    }
    if (mft === 8) {
        return dwy - 242 - leap;
    }
    if (mft === 9) {
        return dwy - 272 - leap;
    }
    if (mft === 10) {
        return dwy - 303 - leap;
    }
    if (mft === 11) {
        return dwy - 333 - leap;
    }
    throw new Error('Invalid time');
}
var HOURS_PER_DAY = 24;
var MINUTES_PER_HOUR = 60;
var SECONDS_PER_MINUTE = 60;
var MS_PER_SECOND = 1e3;
var MS_PER_MINUTE = MS_PER_SECOND * SECONDS_PER_MINUTE;
var MS_PER_HOUR = MS_PER_MINUTE * MINUTES_PER_HOUR;
function hourFromTime(t) {
    return mod(Math.floor(t / MS_PER_HOUR), HOURS_PER_DAY);
}
function minFromTime(t) {
    return mod(Math.floor(t / MS_PER_MINUTE), MINUTES_PER_HOUR);
}
function secFromTime(t) {
    return mod(Math.floor(t / MS_PER_SECOND), SECONDS_PER_MINUTE);
}
function getApplicableZoneData(t, timeZone) {
    var tzData = exports.DateTimeFormat.tzData;
    var zoneData = tzData[timeZone];
    // We don't have data for this so just say it's UTC
    if (!zoneData) {
        return [0, false];
    }
    for (var i = 0; i < zoneData.length; i++) {
        if (zoneData[i][0] * 1e3 >= t) {
            var _a = zoneData[i - 1], offset = _a[2], dst = _a[3];
            return [offset * 1e3, dst];
        }
    }
    return [0, false];
}
function toLocalTime(t, calendar, timeZone) {
    intl_utils_1.invariant(typeof t === 'number', 'invalid time');
    intl_utils_1.invariant(calendar === 'gregory', 'We only support Gregory calendar right now');
    var _a = getApplicableZoneData(t, timeZone), timeZoneOffset = _a[0], inDST = _a[1];
    var tz = t + timeZoneOffset;
    var year = yearFromTime(tz);
    return {
        weekday: weekDay(tz),
        era: year < 0 ? 'BC' : 'AD',
        year: year,
        relatedYear: undefined,
        yearName: undefined,
        month: monthFromTime(tz),
        day: dateFromTime(tz),
        hour: hourFromTime(tz),
        minute: minFromTime(tz),
        second: secFromTime(tz),
        inDST: inDST,
        // IMPORTANT: Not in spec
        timeZoneOffset: timeZoneOffset,
    };
}
exports.DateTimeFormat = function (locales, options) {
    // Cannot use `new.target` bc of IE11 & TS transpiles it to something else
    if (!this || !(this instanceof exports.DateTimeFormat)) {
        return new exports.DateTimeFormat(locales, options);
    }
    initializeDateTimeFormat(this, locales, options);
    /** IMPL START */
    var internalSlots = get_internal_slots_1.default(this);
    var dataLocale = internalSlots.dataLocale;
    var dataLocaleData = exports.DateTimeFormat.localeData[dataLocale];
    intl_utils_1.invariant(dataLocaleData !== undefined, "Cannot load locale-dependent data for " + dataLocale + ".");
    /** IMPL END */
};
// Static properties
intl_utils_1.defineProperty(exports.DateTimeFormat, 'supportedLocalesOf', {
    value: function supportedLocalesOf(locales, options) {
        return intl_utils_1.supportedLocales(exports.DateTimeFormat.availableLocales, Intl.getCanonicalLocales(locales), options);
    },
});
intl_utils_1.defineProperty(exports.DateTimeFormat.prototype, 'resolvedOptions', {
    value: function resolvedOptions() {
        if (typeof this !== 'object' || !(this instanceof exports.DateTimeFormat)) {
            throw TypeError('Method Intl.DateTimeFormat.prototype.resolvedOptions called on incompatible receiver');
        }
        var internalSlots = get_internal_slots_1.default(this);
        var ro = {};
        for (var _i = 0, RESOLVED_OPTIONS_KEYS_1 = RESOLVED_OPTIONS_KEYS; _i < RESOLVED_OPTIONS_KEYS_1.length; _i++) {
            var key = RESOLVED_OPTIONS_KEYS_1[_i];
            var value = internalSlots[key];
            if (key === 'hourCycle') {
                ro.hour12 =
                    value === 'h11' || value === 'h12'
                        ? true
                        : value === 'h23' || value === 'h24'
                            ? false
                            : undefined;
            }
            if (DATE_TIME_PROPS.indexOf(key) > -1) {
                if (internalSlots.dateStyle !== undefined ||
                    internalSlots.timeStyle !== undefined) {
                    value = undefined;
                }
            }
            if (value !== undefined) {
                ro[key] = value;
            }
        }
        return ro;
    },
});
intl_utils_1.defineProperty(exports.DateTimeFormat.prototype, 'formatToParts', {
    value: function formatToParts(date) {
        if (date === undefined) {
            date = Date.now();
        }
        else {
            date = toNumber(date);
        }
        return formatDateTimeParts(this, date);
    },
});
exports.DateTimeFormat.__defaultTimeZone = 'UTC';
exports.DateTimeFormat.__addLocaleData = function __addLocaleData() {
    var data = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        data[_i] = arguments[_i];
    }
    for (var _a = 0, data_1 = data; _a < data_1.length; _a++) {
        var datum = data_1[_a];
        var availableLocales = datum.availableLocales;
        for (var _b = 0, availableLocales_1 = availableLocales; _b < availableLocales_1.length; _b++) {
            var locale = availableLocales_1[_b];
            try {
                var _c = intl_utils_1.unpackData(locale, datum), dateFormat = _c.dateFormat, timeFormat = _c.timeFormat, dateTimeFormat = _c.dateTimeFormat, formats = _c.formats, rawData = __rest(_c, ["dateFormat", "timeFormat", "dateTimeFormat", "formats"]);
                var processedData = __assign(__assign({}, rawData), { dateFormat: {
                        full: skeleton_1.parseDateTimeSkeleton(dateFormat.full),
                        long: skeleton_1.parseDateTimeSkeleton(dateFormat.long),
                        medium: skeleton_1.parseDateTimeSkeleton(dateFormat.medium),
                        short: skeleton_1.parseDateTimeSkeleton(dateFormat.short),
                    }, timeFormat: {
                        full: skeleton_1.parseDateTimeSkeleton(timeFormat.full),
                        long: skeleton_1.parseDateTimeSkeleton(timeFormat.long),
                        medium: skeleton_1.parseDateTimeSkeleton(timeFormat.medium),
                        short: skeleton_1.parseDateTimeSkeleton(timeFormat.short),
                    }, dateTimeFormat: {
                        full: skeleton_1.parseDateTimeSkeleton(dateTimeFormat.full).pattern,
                        long: skeleton_1.parseDateTimeSkeleton(dateTimeFormat.long).pattern,
                        medium: skeleton_1.parseDateTimeSkeleton(dateTimeFormat.medium).pattern,
                        short: skeleton_1.parseDateTimeSkeleton(dateTimeFormat.short).pattern,
                    }, formats: {} });
                for (var calendar in formats) {
                    processedData.formats[calendar] = formats[calendar].map(skeleton_1.parseDateTimeSkeleton);
                }
                exports.DateTimeFormat.localeData[locale] = processedData;
            }
            catch (e) {
                // Ignore if we got no data
            }
        }
    }
    exports.DateTimeFormat.availableLocales = Object.keys(exports.DateTimeFormat.localeData);
    if (!exports.DateTimeFormat.__defaultLocale) {
        exports.DateTimeFormat.__defaultLocale = exports.DateTimeFormat.availableLocales[0];
    }
};
Object.defineProperty(exports.DateTimeFormat.prototype, 'format', formatDescriptor);
exports.DateTimeFormat.__defaultLocale = '';
exports.DateTimeFormat.localeData = {};
exports.DateTimeFormat.availableLocales = [];
exports.DateTimeFormat.getDefaultLocale = function () {
    return exports.DateTimeFormat.__defaultLocale;
};
exports.DateTimeFormat.polyfilled = true;
exports.DateTimeFormat.tzData = {};
exports.DateTimeFormat.__addTZData = function (d) {
    exports.DateTimeFormat.tzData = packer_1.unpack(d);
};
try {
    if (typeof Symbol !== 'undefined') {
        Object.defineProperty(exports.DateTimeFormat.prototype, Symbol.toStringTag, {
            value: 'Intl.DateTimeFormat',
            writable: false,
            enumerable: false,
            configurable: true,
        });
    }
    Object.defineProperty(exports.DateTimeFormat.prototype.constructor, 'length', {
        value: 1,
        writable: false,
        enumerable: false,
        configurable: true,
    });
}
catch (e) {
    // Meta fix so we're test262-compliant, not important
}
