
declare interface CompoundUnitData {
    long: string;
    short: string;
    narrow: string;
}

declare interface CurrencyData {
    displayName: LDMLPluralRuleMap<string>;
    symbol: string;
    narrow: string;
}

/**
 * We only care about insertBetween bc we assume
 * `currencyMatch` & `surroundingMatch` are all the same
 *
 * @export
 * @interface CurrencySpacingData
 */
declare interface CurrencySpacingData {
    beforeInsertBetween: string;
    afterInsertBetween: string;
}

declare type DecimalFormatNum = '1000' | '10000' | '100000' | '1000000' | '10000000' | '100000000' | '1000000000' | '10000000000' | '100000000000' | '1000000000000' | '10000000000000' | '100000000000000';

/**
 * Check if a formatting number with unit is supported
 * @public
 * @param unit unit to check
 */
export declare function isUnitSupported(unit: string): boolean;

declare type LDMLPluralRule = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';

declare type LDMLPluralRuleMap<T> = Omit<Partial<Record<LDMLPluralRule, T>>, 'other'> & {
    other: T;
};

declare type Locale = string;

declare interface LocaleData<T> {
    data: Record<Locale, T>;
    availableLocales: string[];
}

export declare type NumberFormat = NumberFormat_2;

/**
 * https://tc39.es/ecma402/#sec-intl-numberformat-constructor
 */
export declare const NumberFormat: NumberFormatConstructor;

declare interface NumberFormat_2 {
    resolvedOptions(): ResolvedNumberFormatOptions;
    formatToParts(x: number): NumberFormatPart[];
    format(x: number): string;
}

declare interface NumberFormatConstructor {
    new (locales?: string | string[], options?: NumberFormatOptions): NumberFormat_2;
    (locales?: string | string[], options?: NumberFormatOptions): NumberFormat_2;
    __addLocaleData(...data: RawNumberLocaleData[]): void;
    supportedLocalesOf(locales: string | string[], options?: Pick<NumberFormatOptions, 'localeMatcher'>): string[];
    getDefaultLocale(): string;
    __defaultLocale: string;
    localeData: Record<string, NumberFormatLocaleInternalData>;
    availableLocales: string[];
    polyfilled: boolean;
}

declare interface NumberFormatDigitInternalSlots {
    minimumIntegerDigits: number;
    minimumSignificantDigits?: number;
    maximumSignificantDigits?: number;
    roundingType: NumberFormatRoundingType;
    minimumFractionDigits?: number;
    maximumFractionDigits?: number;
    notation?: NumberFormatNotation;
}

declare interface NumberFormatDigitOptions {
    minimumIntegerDigits?: number;
    minimumSignificantDigits?: number;
    maximumSignificantDigits?: number;
    minimumFractionDigits?: number;
    maximumFractionDigits?: number;
}

declare interface NumberFormatInternal extends NumberFormatDigitInternalSlots {
    locale: string;
    dataLocale: string;
    style: NumberFormatOptionsStyle;
    currency?: string;
    currencyDisplay: NumberFormatOptionsCurrencyDisplay;
    unit?: string;
    unitDisplay: NumberFormatOptionsUnitDisplay;
    currencySign: NumberFormatOptionsCurrencySign;
    notation: NumberFormatOptionsNotation;
    compactDisplay: NumberFormatOptionsCompactDisplay;
    signDisplay: NumberFormatOptionsSignDisplay;
    useGrouping: boolean;
    pl: Intl.PluralRules;
    boundFormat?: Intl.NumberFormat['format'];
    numberingSystem: string;
    dataLocaleData: NumberFormatLocaleInternalData;
}

declare interface NumberFormatLocaleInternalData {
    units: UnitDataTable;
    currencies: Record<string, CurrencyData>;
    numbers: RawNumberData;
    nu: string[];
}

declare type NumberFormatNotation = 'standard' | 'scientific' | 'engineering' | 'compact';

export declare type NumberFormatOptions = Intl.NumberFormatOptions & NumberFormatDigitOptions & {
    localeMatcher?: NumberFormatOptionsLocaleMatcher;
    style?: NumberFormatOptionsStyle;
    compactDisplay?: NumberFormatOptionsCompactDisplay;
    currencyDisplay?: NumberFormatOptionsCurrencyDisplay;
    currencySign?: NumberFormatOptionsCurrencySign;
    notation?: NumberFormatOptionsNotation;
    signDisplay?: NumberFormatOptionsSignDisplay;
    unit?: string;
    unitDisplay?: NumberFormatOptionsUnitDisplay;
    numberingSystem?: string;
};

declare type NumberFormatOptionsCompactDisplay = 'short' | 'long';

declare type NumberFormatOptionsCurrencyDisplay = 'symbol' | 'code' | 'name' | 'narrowSymbol';

declare type NumberFormatOptionsCurrencySign = 'standard' | 'accounting';

declare type NumberFormatOptionsLocaleMatcher = 'lookup' | 'best fit';

declare type NumberFormatOptionsNotation = NumberFormatNotation;

declare type NumberFormatOptionsSignDisplay = 'auto' | 'always' | 'never' | 'exceptZero';

declare type NumberFormatOptionsStyle = 'decimal' | 'percent' | 'currency' | 'unit';

declare type NumberFormatOptionsUnitDisplay = 'long' | 'short' | 'narrow';

declare interface NumberFormatPart {
    type: NumberFormatPartTypes;
    value: string;
}

declare type NumberFormatPartTypes = Intl.NumberFormatPartTypes | 'exponentSeparator' | 'exponentMinusSign' | 'exponentInteger' | 'compact' | 'unit' | 'literal';

declare type NumberFormatRoundingType = 'significantDigits' | 'fractionDigits' | 'compactRounding';

declare type NumberingSystem = string;

declare interface RawCurrencyData {
    currencySpacing: CurrencySpacingData;
    standard: string;
    accounting: string;
    short?: Record<DecimalFormatNum, LDMLPluralRuleMap<string>>;
    unitPattern: string;
}

declare interface RawNumberData {
    nu: string[];
    symbols: Record<NumberingSystem, SymbolsData>;
    decimal: Record<NumberingSystem, {
        long: Record<DecimalFormatNum, LDMLPluralRuleMap<string>>;
        short: Record<DecimalFormatNum, LDMLPluralRuleMap<string>>;
    }>;
    percent: Record<NumberingSystem, string>;
    currency: Record<NumberingSystem, RawCurrencyData>;
}

declare type RawNumberLocaleData = LocaleData<NumberFormatLocaleInternalData>;

declare type ResolvedNumberFormatOptions = Intl.ResolvedNumberFormatOptions & Pick<NumberFormatInternal, 'currencySign' | 'unit' | 'unitDisplay' | 'notation' | 'compactDisplay' | 'signDisplay'>;

declare interface SymbolsData {
    decimal: string;
    group: string;
    list: string;
    percentSign: string;
    plusSign: string;
    minusSign: string;
    exponential: string;
    superscriptingExponent: string;
    perMille: string;
    infinity: string;
    nan: string;
    timeSeparator: string;
}

/**
 * Number.prototype.toLocaleString ponyfill
 * https://tc39.es/ecma402/#sup-number.prototype.tolocalestring
 */
export declare function toLocaleString(x: number, locales?: string | string[], options?: NumberFormatOptions): string;

declare interface UnitData {
    long: LDMLPluralRuleMap<string>;
    short: LDMLPluralRuleMap<string>;
    narrow: LDMLPluralRuleMap<string>;
    perUnit: Record<'narrow' | 'short' | 'long', string | undefined>;
}

declare interface UnitDataTable {
    simple: Record<string, UnitData>;
    compound: Record<string, CompoundUnitData>;
}

export { }
