"use strict";
/* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var getLayer_1 = require("./getLayer");
/**
 * ```js
 * import { queryFeatures, decodeValues } from '@esri/arcgis-rest-feature-layer';
 * //
 * const url = `https://sampleserver6.arcgisonline.com/arcgis/rest/services/ServiceRequest/FeatureServer/0`
 * queryFeatures({ url })
 *   .then(queryResponse => {
 *     decodeValues({
 *       url,
 *       queryResponse
 *     })
 *       .then(decodedResponse)
 *   })
 * ```
 * Replaces the raw coded domain values in a query response with descriptions (for legibility).
 *
 * @param requestOptions - Options for the request.
 * @returns A Promise that will resolve with the addFeatures response.
 */
function decodeValues(requestOptions) {
    return new Promise(function (resolve) {
        if (!requestOptions.fields) {
            return getLayer_1.getLayer({ url: requestOptions.url }).then(function (metadata) {
                resolve((requestOptions.fields = metadata.fields));
            });
        }
        else {
            resolve(requestOptions.fields);
        }
    }).then(function (fields) {
        // extract coded value domains
        var domains = extractCodedValueDomains(fields);
        if (Object.keys(domains).length < 1) {
            // no values to decode
            return requestOptions.queryResponse;
        }
        // don't mutate original features
        var decodedFeatures = requestOptions.queryResponse.features.map(function (feature) {
            var decodedAttributes = {};
            for (var key in feature.attributes) {
                /* istanbul ignore next */
                if (!feature.attributes.hasOwnProperty(key))
                    continue;
                var value = feature.attributes[key];
                var domain = domains[key];
                decodedAttributes[key] =
                    value !== null && domain ? decodeValue(value, domain) : value;
            }
            // merge decoded attributes into the feature
            return tslib_1.__assign({}, feature, { attributes: decodedAttributes });
        });
        // merge decoded features into the response
        return tslib_1.__assign({}, requestOptions.queryResponse, { features: decodedFeatures });
    });
}
exports.decodeValues = decodeValues;
function extractCodedValueDomains(fields) {
    return fields.reduce(function (domains, field) {
        var domain = field.domain;
        if (domain && domain.type === "codedValue") {
            domains[field.name] = domain;
        }
        return domains;
    }, {});
}
// TODO: add type for domain?
function decodeValue(value, domain) {
    var codedValue = domain.codedValues.find(function (d) {
        return value === d.code;
    });
    return codedValue ? codedValue.name : value;
}
//# sourceMappingURL=decodeValues.js.map