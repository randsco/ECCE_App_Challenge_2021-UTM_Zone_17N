/// <reference types="seamless-immutable" />
import { ServiceDefinition, IMDataSourceJson, IMDataSourceSchema, IMFieldSchema, IMReversedDataSourceSchema, Immutable } from 'jimu-core';
import { IFeature } from '@esri/arcgis-rest-types';
import { AbstractQueriableDataSource } from '../ds-base-types/abstract-queriable-data-source';
import { DataSourceConstructorOptions, DataSourceTypes, SceneLayerDataSource, IMFeatureLayerQueryParams, QueryResult, FeatureDataRecord, FeatureLayerQueryParams, CodedValue, WidgetDataSourcePair, QueryOptions, DataRecord, QueryParams, DataSource } from '../data-source-interface';
import { FeatureLayerDataSourceImpl } from './feature-layer-data-source-impl';
export interface SceneLayerDataSourceConstructorOptions extends DataSourceConstructorOptions {
    layer?: __esri.SceneLayer;
}
export declare class SceneLayerDataSourceImpl extends AbstractQueriableDataSource implements SceneLayerDataSource {
    portalUrl?: string;
    itemId?: string;
    layerId?: string;
    layer?: __esri.SceneLayer;
    private layerDefinition;
    private associatedDataSource;
    url: string;
    type: DataSourceTypes.SceneLayer;
    constructor(options: SceneLayerDataSourceConstructorOptions);
    ready(): Promise<void>;
    private onInfoChange;
    createAssociatedDataSource(): Promise<FeatureLayerDataSourceImpl>;
    private _createAssociatedDataSourceWithLayer;
    private _createAssociatedDataSourceWithUrl;
    private _getNewAssociatedDataSourceId;
    fetchLayerDefinition(): Promise<ServiceDefinition>;
    getLayerDefinition(): ServiceDefinition;
    fetchSchema(): Promise<Immutable.ImmutableObject<import("jimu-core").DataSourceSchema>>;
    getSchema(): IMDataSourceSchema;
    setSchema(schema: IMDataSourceSchema): void;
    setDataSourceJson(dsJson: IMDataSourceJson): void;
    getFetchedSchema(): IMDataSourceSchema;
    setFetchedSchema(fetchedSchema: IMDataSourceSchema): void;
    getReversedConfigSchema(): IMReversedDataSourceSchema;
    getSelectedFields(): {
        [jimuName: string]: IMFieldSchema;
    };
    getIdField(): string;
    setJsonData(data: (IFeature | __esri.Graphic)[]): void;
    queryById(id: string): Promise<FeatureDataRecord>;
    addRecord(record: FeatureDataRecord): Promise<FeatureDataRecord>;
    updateRecord(record: DataRecord): Promise<DataRecord>;
    deleteRecord(index: number): Promise<void>;
    doQuery(queryProperties: IMFeatureLayerQueryParams): Promise<QueryResult>;
    doQueryById(id: string): Promise<FeatureDataRecord>;
    doQueryCount(queryProperties: IMFeatureLayerQueryParams): Promise<QueryResult>;
    getConfigQueryParams(): FeatureLayerQueryParams;
    getRemoteQueryParams(): FeatureLayerQueryParams;
    getCurrentQueryParams(excludeOption?: WidgetDataSourcePair): FeatureLayerQueryParams;
    getRuntimeQueryParamsgetRuntimeQueryParams(excludeWidgetId?: string): QueryParams;
    getCurrentQueryId(): string;
    mergeQueryParams(baseQuery: FeatureLayerQueryParams, newQuery: FeatureLayerQueryParams): FeatureLayerQueryParams;
    getFieldCodedValueList(jimuFieldName: string, record?: FeatureDataRecord): CodedValue[];
    getRealQueryParams(query: any, flag: 'query' | 'load', options?: QueryOptions): FeatureLayerQueryParams;
    updateQueryParams(query: QueryParams, widgetId: string): void;
    getGDBVersion(): string;
    getQueryPageSize(): number;
    getMaxRecordCount(): number;
    getRecordsByPage(page: number, pageSize: number): DataRecord[];
    getPagesData(): {
        [page: number]: DataRecord[];
    };
    setPagesData(pages: {
        [page: number]: DataRecord[];
    }): void;
    getRealQueryPages(page: number, pageSize: number): number[];
    load(query: QueryParams, options?: QueryOptions): Promise<DataRecord[]>;
    loadCount(query: QueryParams, options?: QueryOptions): Promise<number>;
    query(query: QueryParams, options?: QueryOptions): Promise<QueryResult>;
    queryCount(query: QueryParams, options?: QueryOptions): Promise<QueryResult>;
    loadById(id: string, refresh?: boolean): Promise<DataRecord>;
    changeGDBVersion(gdbVersion: string): void;
    getAssociatedDataSource(): FeatureLayerDataSourceImpl;
    private getAssociatedDataSourceById;
    private fixQueryOptions;
    private fixExcludeQuery;
    private _getRealAssociatedDataSourceId;
    clearData(): void;
    setRecords(records: DataRecord[]): void;
    getRecords(): DataRecord[];
    getSelectedRecords(): DataRecord[];
    getSelectedRecordIndexes(): number[];
    getSelectedRecordIds(): string[];
    nextRecord(): DataRecord;
    prevRecord(): DataRecord;
    getRecord(index: number): DataRecord;
    getRecordById(id: string): DataRecord;
    clearSelection(): void;
    addVersion(): void;
    selectRecord(index: number): void;
    selectRecords(indexes: number[]): void;
    selectRecordById(id: string, record?: DataRecord): void;
    selectRecordsByIds(ids: string[], records?: DataRecord[]): void;
    destroy(): void;
    getRootLayerDataSource(): DataSource;
    getOriginalDataId(): string | number;
    private _mergeAssociatedDataSourceJson;
    get count(): number;
    set count(count: number);
}
